\documentclass[12pt]{article}

\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usetikzlibrary{trees, automata,calc,shapes}
\usetikzlibrary{arrows.meta,positioning, decorations.pathmorphing}

\begin{document}

Statement of the problem: we have a finite alphabet $\Sigma$, and rules of the form $a\to aa$ and $ab\to c$, where $a,b,c$ are letters from a finite alphabet $\Sigma$. We start with a source word $u$, and we want to generate the language $L$ that contains all words that can be obtained by applying the rules to the source word. The question is whether this language $L$ is regular.


We will show that the language $L$ generated from the source word is regular, in a constructive way, yielding decidability of the problem. 

The alphabet can be partitioned into $\Sigma=\Sigma_d\uplus\Sigma_n$, where $\Sigma_d$ are the duplicating letters, ie $\Sigma_d:=\{\sigma\in \Sigma\mid\exists\text{ rule }\sigma\to\sigma\sigma\}$ and $\Sigma_n:=\Sigma\setminus\Sigma_d$.

Let $R$ be the set of rules. If $u\in\Sigma^*$ is a word, we denote by  $L_R(u)$ the language generated by $u$ via the rules $R$. If $X\subseteq\Sigma^*$, we denote by $L_R(X)$ the language generated by $X$, ie $L_R(X):=\bigcup_{u\in X}L_R(u)$.

The heavy lifting will be done by the following lemma, we will see later how to use it to obtain the complete solution:

**Lemma 1:** Let $s_1,s_2\in\Sigma_d$, then $L_R(s_1^*s_2^*)$ is regular.


**Proof:**
Let $L=L_R(s_1^*s_2^*)$. 

We will give an iterative construction building an automaton at each step, that will eventually stop with a correct automaton for $L$.

If $a\in\Sigma_d$, we define $a^\uparrow$ the subset of $\Sigma$ that contains $a$ and that is closed under application of rules, ie $x,y\in a^\uparrow$ and $xy\to z$ implies $z\in a^\uparrow$. It corresponds to the set of letters that can be repeated if we start from $a$.

Let $A_1=s_1^\uparrow$ and $A_2=s_2^\uparrow$. The language $L$ contains at least $A_1^*A_2^*$.

If $X$ is a set of letters, let us define $X^\uparrow=\bigcup_{a\in X\cap\Sigma_d} a^\uparrow$, and $X_s=\{\varepsilon\}\cup (X\setminus X^\uparrow)$.

If $A,B$ are sets of letters, let $A\otimes B:=\{z\in\Sigma\mid \exists x\in A,y\in B,\text{ and a rule } xy\to z\}$.
For all pairs $(A,B)$, we will maintain a set $\mathrm{I}(A,B)\subseteq\Sigma$, initialized originally to $A\otimes B$, and that will be updated (by adding new letters in it) during the algorithm. This represents the letters that can be generated at the interface of $A$ and $B$.


We now build a tree that gathers ways of parsing a word from $L$. Nodes of this tree are labeled by pairs of the form $(X^\uparrow,Y^\uparrow)$, for sets $X,Y\subseteq \Sigma$.
We also build at the same time a relation $\mathrm{next}$, giving for each node some possible next nodes, that will be used when building an automaton from the tree, and tells where to go next when reading the word from left to right.

The root of the tree is labeled by $(A_1,A_2)$.

For each node $(A,B)$ of the tree, we build its children in the following way: let $C=I(A,B)$. Intuitively, a word generated from a node $p$ labelled by $(A,B)$ is either directly of the form $A^*C_sB^*$, or it is a concatenation of words generated from $(A,c^\uparrow)$ and $(c^\uparrow, B)$, for some $c\in C\cap\Sigma_d$. 
Thus, for each such $c^\uparrow$, we build two children of $p$: we build  $p^{c^\uparrow}_\mathrm{left}$ labeled $(A,c^\uparrow)$, and its "right brother" $p^{c^\uparrow}_\mathrm{right}$ labeled $(c^\uparrow,B)$. Notice that we may have $d\neq c$ with $d\in C\cap\Sigma_d$ and $d\in c^\uparrow$, in which case we do not need separate children for $d$, as it is covered in $c^\uparrow$.
 We initially set $\mathrm{next}(p^c_\mathrm{left})=\{p^c_\mathrm{right}\}$ and $\mathrm{next}(p^c_\mathrm{right})=\mathrm{next}(p)$.
If $p$ has an ancestor $q$ that is also labeled $(A,B)$, we do not generate any children, however, we update the relation $\mathrm{next}$ in the following way: for any node $r$ with $\mathrm{next}(r)\supseteq\mathrm{next}(q)$, we augment $\mathrm{next}(r)$ with $\mathrm{next}(p)$. Intuitively this corresponds to identifying $p$ and $q$, and maintaining consistent sets of successors accordingly.

This process terminates: the tree is finitely branching, and each branch has finite length since the number of possible labels is finite.


We finally use this tree as a base for an automaton, more precisely an $\varepsilon$-NFA in slightly generalized form (with outgoing accepting edges labeled by regular expressions), with same state space.
The initial state is the root.
For each state $p=(A,B)$, let $C=I(A,B)$, we put edges :

 - $p\stackrel{A}{\to}p$ (as usual this means any $a\in A$ is allowed)
 - $p\stackrel{\varepsilon}{\to}p^{c^\uparrow}_\mathrm{left}$ for all $c\in I(A,B)\cap\Sigma_d$.
 - if $p$ has no children because it has same label as an ancestor $q$, we add a transition $p\stackrel{\varepsilon}{\to}q$.
 - $p\stackrel{C_s}{\to}q$ for all $q\in\mathrm{next}(p)$ (in particular if $q$ is the right brother of $p$).
 - for all $p$, we add an accepting outgoing edge $p\stackrel{C_sB^*}{\to}\text{Accepts}$.


Let us give a first example showing some of the basic behaviour of the construction.

The alphabet is $\Sigma=\{a,b,c,d,e,g\}$ with starting word $ab$, duplicating set $\Sigma_d=\{a,b,c,g\}$, and other rules $ab\to c$, $ab\to g$, $cb\to a$, $cb\to d$, and $ca\to e$.

We obtain the following tree, using notation $(a,b)$ instead of $(\{a\},\{b\})$ to ease reading. The relation $\mathrm{next}$ is marked with green zigzag arrows:

$\hspace{3cm} $[![tree1][1]][1]

This results in the following $\varepsilon$-NFA:

$\hspace{1cm} $ [![NFA1][2]][2]

The NFA recognizes the correct language.

Let us give another example showing why we need to update the $\mathrm{next}$ relation when creating back-edges.

We now take $\Sigma=\Sigma_d=\{a,b,c\}$, and rules $ab\to c$ and $ac\to b$, still starting with word $ab$.

We obtain the following tree:

$\hspace{3cm} $[![tree2][3]][3]

and the following automaton:

$\hspace{1cm} $[![NFA2][4]][4]
 

Notice that the green edge corresponds to an intuitive continuation. But the red edge is also needed, and it is here thanks to the fact that $(b,c)$ was added to $\mathrm{next}(c,b)$ when creating the leaf $(a,b)$.

We could worry about this kind of edge not corresponding to an actual decomposition, and adding words not from $L$ to the language of the automaton. This cannot happen because if $p$ is a leaf with same label as an ancestor $q$, there are $\varepsilon$-paths $p\stackrel{\varepsilon}{\to^*}q$ and $q\stackrel{\varepsilon}{\to^*}p$, so we could always assume that such paths have been taken whenever needed to justify this continuation.

Let us finally explain why the procedure may not be over, and why we might need to increase the interface sets $I(A,B)$.
Indeed, in the first example above, if we add a rule $ed\to f$, the letter $f$ should be generated as well, but it will not be discovered by the current construction.
To fix this, we add a step at the end of the construction: for each rule $xy\to z$, if there is a path labelled by $xy$ in the automaton from $(A,B)$ to $(C,D)$, we add $z$ to $I(A,C)$. Similarly, if there is a  path labelled $x$ from $(A,B)$ to $(C,D)$ with $y\in I(C,D)\cup D$ (to treat the case where $y$ is on an accepting edge as in our example), we add $z$ to $I(A,D)$.
We also add single letters that were discovered deeper in the tree, by simply adding $x$ to $I(A,C)$ whenever there is a path $(A,B)\to (C,D)$ labeled $x$ (and $x\notin A\cup C$).

Here, we would add $f$ to $I(a,b)$ and $I(c,b)$ (by applying rule $ed\to f$).

We then restart the construction from the beginning, with these new augmented interface sets, and repeat this procedure until no new letters are added to any of the interface sets $I(A,B)$.

In this example, this automaton generated in the second step recognizes the correct language $(a+c+e)^*(\varepsilon+d+f)b^*$, thanks to the new interface set $I(c,b)=\{d,f\}$.

This process terminates because the sets $I(A,B)$ can only grow finitely many times.

This concludes the proof of Lemma 1.

-----

Let us now show how to use this lemma to prove that $L_R(u)$ is regular, for any finite word $u=a_1\dots a_n$.

**Theorem:** Let $u=a_1a_2\dots a_n\in\Sigma^*$, then $L_R(u)$ is regular.

**Proof:**
Let $\mathrm{Int}_n:=\{[i,j]\mid 1\leq i\leq j\leq n\}$ be the set of intervals of indices of the letters of $u$.
We will augment the alphabet $\Sigma$ to $\Sigma'=\Sigma\times\mathrm{Int}_n$. 

All rules of $R$ are modified to the following rules $R'$:
For $a\to aa$ in $R$, and all $I\in\mathrm{Int}_n$, we have $(a,I)\to (a,I)(a,I)$.
For $ab\to c$ in $R$, and all $I,J\in\mathrm{Int}_n$ such that $I\cup J$ is an interval, we have $(a,I)(b,J)\to (c,I\cup J)$.
This allows us to keep track of the provenance of each letter generated.

Finally, let us call $\pi$ the projection from $\Sigma'^*\to\Sigma^*$, ie $\pi((x_1,I_1)(x_2,I_2)\dots(x_k,I_k))=x_1x_2\dots x_k$.

Now, if $u=a_1a_2\dots a_n$, let $u'=(a_1,[1,1])(a_2,[2,2])\dots(a_n,[n,n])$ be the corresponding word in $\Sigma'$. Let us call $a_i'$ the letter $(a_i,[i,i])$ in $\Sigma'$, for all $i\in[1,n]$.

The idea is that the second component will allow us to make sure that all letters $a_1,\dots,a_n$ are used at least once to produce the output. 
This will be witnessed via the following language: let $K\subseteq\Sigma'^*$ be the regular language of words $(x_1,I_1)(x_2,I_2)\dots(x_k,I_k)$ such that $I_1\cup I_2\cup\dots\cup I_k=[1,n]$.

Remark that $L_{R'}(u')\subseteq K$, and $L_R(u)=\pi(L_{R'}(u'))$.

In order to be able to use directly Lemma 1 as a blackbox, we will now enrich $R'$ and $\Sigma'$ with new rules and letters to obtain rules $R''$ and alphabet $\Sigma''$, so that $L_{R'}(u')=L_{R''}(a^*b^*)\cap K$ for some new letters $a,b\in\Sigma''$.

The new letters will be $b_0,b_1,\dots,b_n$, and the new rules are the following:
- $b_i\to b_ib_i$ for all $i\in[0,n]$,
- $b_{i-1} b_n\to b_{i}$ for all $i\in[1,n-1]$,
- $b_{i-1}b_{i}\to a_i'$ for all $i\in[1,n]$.

Notice that the words generated from $b_0^*b_n^*$ using only these new rules are exactly $b_0^*(\varepsilon+a_1')b_1^*(\varepsilon+a_2')\dots b_{n-1}^*(\varepsilon+a_n')b_n^*$.
This way, $u'\in L_{R''}(b_0^*b_n^*)$, and moreover, $L_{R''}(b_0^*b_n^*)\cap K=L_{R'}(u')$. This is because $K$ verifies that all letters $a_1',\dots,a_n'$ appear, while none of the new letters do.

We can now apply Lemma 1 to $L_{R''}(b_0^*b_n^*)$, and obtain that it is regular. 

Finally, we have $L_R(u)=\pi(L_{R''}(b_0^*b_n^*)\cap K)$, which is regular since $\pi$ is a homomorphism and $K$ is regular. This concludes the proof of the main theorem.

---

\bigskip
LATEX FIGURES

We obtain the following tree, using notation $(a,b)$ instead of $(\{a\},\{b\})$ to ease reading:

%tree1 picture
\tikzset{
  zigedge/.style={
    ->, green,
    decorate, decoration={zigzag,segment length=1mm,amplitude=.3mm}
  }
}
\begin{center}
  \begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm]
    \node (ab) {$(a,b)$}
      child {node (ac) {$(a,c)$}}
      child {node (cb) {$(c,b)$}
        child {node (ca) {$(c,a)$}}
        child {node (ab2) {$(a,b)$}}
      }
      child {node (ag) {$(a,g)$}}
      child {node (gb) {$(g,b)$}}
      ;
    %path from next relation, in green and squiggly, from ac->cb and ca->ab
    \path[->,green]
    (ac) edge[zigedge] (cb)
    (ca) edge[zigedge] (ab2)
    (ag) edge[zigedge] (gb)
    ;

  \end{tikzpicture}
  \end{center}
  

This results in the following $\varepsilon$-NFA:

%NFA1 picture
%-----------------------------------------------------------------
\tikzset{
  state/.style ={rounded rectangle,draw,inner sep=2pt,font=\small},
  eps/.style   ={->,>=Stealth,auto=false,font=\footnotesize}  % upright labels
}

\begin{center}
\begin{tikzpicture}[node distance = 22mm and 10mm]

% ----------- nodes (same horizontal layout as the tree) ----------
\node[state,initial] (n0) {$(a,b)$};


\node[state] (n2) [below  left     =of n0] {$\,(c,b)\,$};
\node[state] (n1) [left =of n2] {$\,(a,c)\,$};

\node[state] (g1) [below right =of n0] {$\,(a,g)\,$};
\node[state] (g2) [right =of g1] {$\,(g,b)\,$};

%\node[state] (n3) [below right =of n0] {$(a,\{\varepsilon\},b)$};

\node[state] (n4) [below left =of n2] {$\,(c,a)\,$};
\node[state] (n5) [below  right     =of n2] {$\,(a,b)\,$};
%\node[state] (n6) [below right =of n2] {$(c,\{d,\varepsilon\},b)$};

% non‑overlapping accepting sinks
%\node[state,accepting] (sink) [right =22mm of n2] {$\text{Accept}_{b}$};


% ---------------- self‑loops on first component ------------------
\foreach \N/\lab/\dir in {n0/a/above,n1/a/left,n4/c/left,n5/a/right}%
  \path (\N) edge[loop \dir] node[font=\footnotesize] {$\lab$} ();

  \path (n2) edge[loop right] node[above, font=\footnotesize] {$c$} ();
  \path (g1) edge[loop above] node[font=\footnotesize] {$a$} ();
  \path (g2) edge[loop right] node[font=\footnotesize] {$g$} ();
% ---------------- ε‑edges root → children ------------------------
\path[eps] (n0) edge node[above left ] {$\varepsilon$} (n1);
%\path[eps] (n0) edge node[left       ] {$\varepsilon$} (n2);
%\path[eps] (n0) edge node[above right] {$\varepsilon$} (n3);

\path[eps] (n0) edge node[above right] {$\varepsilon$} (g1);

% ε from every left child to its right brother
\path[eps] (n1) edge[bend left=8] node[above] {$\varepsilon$} (n2);
\path[eps] (n4) edge[bend left=8] node[above] {$\varepsilon,e$} (n5);

\path[eps] (g1) edge[bend left=8] node[above] {$\varepsilon$} (g2);

% ---------------- edges out of (c,b) -----------------------------
\path[eps] (n2) edge node[left ] {$\varepsilon$} (n4);
%\path[eps] (n2) edge node[right] {$\varepsilon$} (n5);
%\path[eps] (n2) edge node[above] {$\varepsilon$} (n6);

% ε back‑edge for the repeated label (a,b)
\path[eps] (n5) edge node[right] {$\varepsilon$} (n0);

% ---------------- right‑uncle transitions & sinks ----------------
% (a,{d,ε},b)  – no right‑uncle
%accepting outgoing edge from n0, going diagonally up right to an invisible state
%to n0+(0.5,0.5) is the same as n0++ but with a different label
\path (n0) edge[->] node[above] {$b^*$} ++(1,1);
\path (n2) edge[->] node[above left, xshift=8pt, yshift=-5pt] {$(\varepsilon+d)b^*$} ++(1.2,.9);
\path (n1) edge[->] node[above] {$c^*$} ++(1,1);
\path (n4) edge[->] node[above right,, xshift=7pt, yshift=-1pt] {$(\varepsilon+e)a^*$} ++(1,1);
\path (n5) edge[->] node[right] {$b^*$} ++(1,1);
\path (g1) edge[->] node[above] {$g^*$} ++(1,1);
\path (g2) edge[->] node[above] {$b^*$} ++(1,1);

\end{tikzpicture}
\end{center}



We obtain the following tree:


%tree2 picture
\begin{center}
  \begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm]
    \node {$(a,b)$}
      child {node (ac) {$(a,c)$}
        child {node (ab) {$(a,b)$}}
        child {node  (bc) {$(b,c)$}}
      }
      child {node (cb) {$(c,b)$}
      };
    %path from next relation, in green and squiggly, from ac->bc and ab->bc
    \path[->,green]
    (ac) edge[zigedge] (cb)
    (ab) edge[zigedge] (bc)
    (cb) edge[zigedge, bend left] (bc)
    (bc) edge[zigedge, bend left] (cb)
    ;
  \end{tikzpicture}
  \end{center}


and the following automaton:


%NFA2 picture
\begin{center}
  \begin{tikzpicture}[node distance = 22mm and 10mm]
  % ----------- nodes (same horizontal layout as the tree) ----------
  \node[state,initial] (n0) {$(a,b)$};
  \node[state] (n1) [below left =of n0] {$\,(a,c)\,$};
  \node[state] (n2) [below  right     =of n0] {$\,(c,b)\,$};
  \node[state] (n3) [below left =of n1] {$\,(a,b)\,$};
  \node[state] (n4) [below right =of n1] {$\,(b,c)\,$};
  
  
  % ---------------- self‑loops on first component ------------------
  \foreach \N/\lab/\dir in {n0/a/above,n1/a/left,n3/a/left,n4/b/right}%
    \path (\N) edge[loop \dir] node[font=\footnotesize] {$\lab$} ();
  \path (n2) edge[loop right] node[above, font=\footnotesize] {$c$} ();
  % ---------------- ε‑edges root → children ------------------------
  \path[eps] (n0) edge node[left] {$\varepsilon$} (n1);
  \path[eps] (n1) edge node[left] {$\varepsilon$} (n3);
  % ε from every left child to its right brother
  \path[eps] (n1) edge[bend left=8] node[above] {$\varepsilon$} (n2);
  \path[eps] (n3) edge[bend left=8] node[above] {$\varepsilon$} (n4);
  % ---------------- edges out of (c,b) -----------------------------
  
  
  % ε back‑edge for the repeated label (a,b)
  \path[eps] (n3) edge[bend left=55] node[left] {$\varepsilon$} (n0);
  % ---------------- right‑uncle transitions & sinks ----------------
  \path[eps] (n2) edge[red,bend left] node[right] {$\varepsilon$} (n4);
  \path[eps] (n4) edge[green,bend left] node[left] {$\varepsilon$} (n2);
  
  \path (n0) edge[->] node[above] {$b^*$} ++(1,1);
  \path (n2) edge[->] node[above] {$b^*$} ++(1,1);
  \path (n1) edge[->] node[right] {$c^*$} ++(1,1);
  \path (n3) edge[->] node[right] {$b^*$} ++(1,1);
  \path (n4) edge[->] node[right] {$c^*$} ++(1,-1);
  \end{tikzpicture}
  \end{center}
  
\end{document}